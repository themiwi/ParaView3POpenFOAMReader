/*=========================================================================

    This file is part of pqPOpenFOAMPanel.

    vtkPOpenFOAMReader is free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    vtkPOpenFOAMReader is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with vtkPOpenFOAMReader.  If not, see
    <http://www.gnu.org/licenses/>.

=========================================================================*/
// Copyright (c) 2008-2009 Takuya OSHIMA <oshima@eng.niigata-u.ac.jp>.
// All rights reserved.

#include "pqPOpenFOAMPanel.h"

// Qt
#include <QGridLayout>
#include <QIntValidator>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QString>
#include <QTimer>
#include <QToolButton>

// UI
#include "pqAnimationScene.h"
#include "pqApplicationCore.h"
#include "pqPipelineRepresentation.h"
#include "pqPipelineSource.h"
#include "pqServerManagerModel.h"
#include "pqView.h"

// server manager
#include "vtkSMDoubleVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMProperty.h"
#include "vtkSMSourceProxy.h"

//-----------------------------------------------------------------------------
pqPOpenFOAMPanel::pqPOpenFOAMPanel(pqProxy *pxy, QWidget *p)
  : pqAutoGeneratedObjectPanel(pxy, p)
{
  this->Sp = vtkSMSourceProxy::SafeDownCast(this->proxy());
  this->Ps = qobject_cast<pqPipelineSource *>(pxy);

  // create timer
  this->Timer = new QTimer(this);
  this->Timer->setSingleShot(false);
  QObject::connect(this->Timer, SIGNAL(timeout()), this, SLOT(onTimeout()));

  // create sublayout
  QGridLayout *grid = new QGridLayout();
  this->PanelLayout->addLayout(grid, 0, 0, 1, -1);
  grid->setColumnStretch(4, 1); // column 4 will be empty stretching spacing

  // create label for watching interval
  QLabel *label = new QLabel("Interval [s]", this);
  grid->addWidget(label, 0, 0, Qt::AlignLeft);

  // create line edit for changing interval
  vtkSMIntVectorProperty *uiInterval
    = vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiInterval"));
  uiInterval->SetImmediateUpdate(1);
  this->IntEdit = new QLineEdit(QString("%1").arg(uiInterval->GetElement(0)), this);
  this->onEditingFinished(); // manually fire the slot
  this->IntEdit->setMaximumSize(this->IntEdit->minimumSizeHint().width() + 20,
      this->IntEdit->maximumSize().height());
  QIntValidator *valid = new QIntValidator(this->IntEdit);
  valid->setBottom(1);
  this->IntEdit->setValidator(valid);
  this->IntEdit->setToolTip("The interval for watching a case.");
  QObject::connect(this->IntEdit, SIGNAL(editingFinished()), this,
      SLOT(onEditingFinished()));
  grid->addWidget(this->IntEdit, 0, 1, Qt::AlignLeft);

  // create rescale button
  vtkSMIntVectorProperty *uiRescale
    = vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiRescale"));
  uiRescale->SetImmediateUpdate(1);
  this->Rescale = new QToolButton(this);
  this->Rescale->setText("Rescale");
  this->Rescale->setCheckable(true);
  this->Rescale->setChecked(uiRescale->GetElement(0));
  this->Rescale->setToolTip("When watching a case, whether autoscaling of scalar data is"
      " applied every time the scene is updated.");
  QObject::connect(this->Rescale, SIGNAL(toggled(bool)), this, SLOT(onRescaleToggled(bool)));
  grid->addWidget(this->Rescale, 0, 2, Qt::AlignLeft);

  // create watch button
  vtkSMIntVectorProperty *uiWatch
    = vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiWatch"));
  uiWatch->SetImmediateUpdate(1);
  QToolButton *watch = new QToolButton(this);
  watch->setText("Watch");
  watch->setCheckable(true);
  // connect before setChecked() so that the slot is fired as necessary
  QObject::connect(watch, SIGNAL(toggled(bool)), this, SLOT(onWatchToggled(bool)));
  watch->setChecked(uiWatch->GetElement(0));
  watch->setToolTip("Watch the case with the specified interval and update the scene with"
      " the latest timestep.");
  grid->addWidget(watch, 0, 3, Qt::AlignLeft);

  // create refresh button and place the button at top-right of the layout grid
  this->Sp->GetProperty("Refresh")->SetImmediateUpdate(1);
  QPushButton *refresh = new QPushButton("Refresh", this);
  refresh->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
  refresh->setToolTip("Rescan timesteps and reload mesh and field data.");
  QObject::connect(refresh, SIGNAL(clicked()), this, SLOT(onRefresh()));
  grid->addWidget(refresh, 0, 5, Qt::AlignRight);
}

//-----------------------------------------------------------------------------
// Rescale scalar ranges of all relevant representations and render views
void pqPOpenFOAMPanel::rescaleAndRender()
{
  QList<pqView *> views = this->Ps->getViews();
  foreach (pqView *view, views)
    {
    QList<pqDataRepresentation *> data = this->Ps->getRepresentations(view);
    // rescale scalar ranges
    foreach (pqDataRepresentation *datum, data)
      {
      pqPipelineRepresentation *pipe
         = qobject_cast<pqPipelineRepresentation *>(datum);
      if(pipe)
        {
        pipe->resetLookupTableScalarRange();
        }
      }
    // render the view
    view->render();
    }
  
  // If one is happy with only updating the active view
  //   if(this->view())
  //    {
  //    this->view()->render();
  //    }
  // All relevant views may be rendered this way as well
  //   this->Ps->renderAllViews();
  // All views including irrelevant ones may be rendered by
  //   pqApplicationCore::instance()->render();
  // Or there's even another way
  //   vtkSMProxyIterator *pIt = vtkSMProxyIterator::New();
  //   pIt->SetModeToOneGroup();
  //   for(pIt->Begin("views"); !pIt->IsAtEnd(); pIt->Next())
  //     {
  //     vtkSMViewProxy::SafeDownCast(pIt->GetProxy())->StillRender();
  //     }
  //   pIt->Delete();
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onEditingFinished()
{
  // onEditingFinished is called only when the entered text is acceptable
  const int interval = this->IntEdit->text().toInt();
  vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiInterval"))->SetElement(0, interval);
  this->Timer->setInterval(1000 * interval); // convert to msec
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onRescaleToggled(const bool checked)
{
  vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiRescale"))->SetElement(0, checked);
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onWatchToggled(const bool checked)
{
  vtkSMIntVectorProperty::SafeDownCast(this->Sp->GetProperty("UiWatch"))->SetElement(0, checked);
  if(checked)
    {
    this->Timer->start();
    }
  else
    {
    this->Timer->stop();
    }
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onRefresh()
{
  // force updating everything (RequestInformation() + RequestData())
  this->Sp->GetProperty("Refresh")->Modified();
  this->Sp->UpdatePipeline();

  this->rescaleAndRender();
}

//-----------------------------------------------------------------------------
// Update pipeline and set scene to the last timestep
void pqPOpenFOAMPanel::onTimeout()
{
  // only update pipeline information (RequestInformation())
  this->Sp->GetProperty("Refresh")->Modified();
  this->Sp->UpdatePipelineInformation();
  this->Sp->UpdatePropertyInformation(); // explicitly pull the property information

  // get the last timestep
  vtkSMDoubleVectorProperty *tsv
      = vtkSMDoubleVectorProperty::SafeDownCast(this->Sp->GetProperty("TimestepValues"));
  if(tsv->GetNumberOfElements() > 0)
    {
    const double lastStep = tsv->GetElement(tsv->GetNumberOfElements() - 1);
    pqApplicationCore *app = pqApplicationCore::instance();

    // set animation time to the last timestep
    QList<pqAnimationScene*> scenes
        = app->getServerManagerModel()->findItems<pqAnimationScene *>();
    foreach (pqAnimationScene *scene, scenes)
      {
      scene->setAnimationTime(lastStep);
      }

    if(this->Rescale->isChecked())
      {
      this->rescaleAndRender();
      }
    }
}
