/*=========================================================================

    This file is part of vtkPOpenFOAMReader.

    vtkPOpenFOAMReader is free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    vtkPOpenFOAMReader is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with vtkPOpenFOAMReader.  If not, see
    <http://www.gnu.org/licenses/>.

=========================================================================*/
// Copyright (c) 2008-2009 Takuya OSHIMA <oshima@eng.niigata-u.ac.jp>.
// All rights reserved.

#include "pqPOpenFOAMPanel.h"

// Qt
#include <QGridLayout>
#include <QIntValidator>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QTimer>
#include <QToolButton>

// UI
#include "pqAnimationScene.h"
#include "pqApplicationCore.h"
#include "pqPipelineRepresentation.h"
#include "pqServerManagerModel.h"

// server manager
#include "vtkSMDoubleVectorProperty.h"
#include "vtkSMProperty.h"
#include "vtkSMProxyIterator.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMViewProxy.h"

//-----------------------------------------------------------------------------
pqPOpenFOAMPanel::pqPOpenFOAMPanel(pqProxy *pxy, QWidget *p)
  : pqAutoGeneratedObjectPanel(pxy, p)
{
  // create timer
  this->Timer = new QTimer(this);
  this->Timer->setSingleShot(false);
  QObject::connect(this->Timer, SIGNAL(timeout()), this, SLOT(onTimeout()));

  // create sublayout
  QGridLayout *grid = new QGridLayout();
  this->PanelLayout->addLayout(grid, 0, 0, 1, -1);
  grid->setColumnStretch(4, 1); // column 4 will be empty stretching spacing

  // create label for watching interval
  QLabel *label = new QLabel("Interval [s]", this);
  grid->addWidget(label, 0, 0, Qt::AlignLeft);

  // create line edit for changing interval
  this->IntEdit = new QLineEdit("60", this);
  this->onEditingFinished();
  this->IntEdit->setMaximumSize(this->IntEdit->minimumSizeHint().width() * 3,
      this->IntEdit->maximumSize().height());
  QIntValidator *valid = new QIntValidator(this->IntEdit);
  valid->setBottom(1);
  this->IntEdit->setValidator(valid);
  QObject::connect(this->IntEdit, SIGNAL(editingFinished()), this,
      SLOT(onEditingFinished()));
  grid->addWidget(this->IntEdit, 0, 1, Qt::AlignLeft);

  // create rescale button
  this->Rescale = new QToolButton(this);
  this->Rescale->setText("Rescale");
  this->Rescale->setCheckable(true);
  grid->addWidget(this->Rescale, 0, 2, Qt::AlignLeft);

  // create watch button
  QToolButton *watch = new QToolButton(this);
  watch->setCheckable(true);
  watch->setText("Watch");
  QObject::connect(watch, SIGNAL(toggled(bool)), this, SLOT(onToggled(bool)));
  grid->addWidget(watch, 0, 3, Qt::AlignLeft);

  // create refresh button and place the button at top-right of the layout grid
  QPushButton *refresh = new QPushButton("Refresh", this);
  refresh->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
  QObject::connect(refresh, SIGNAL(clicked()), this, SLOT(onRefresh()));
  grid->addWidget(refresh, 0, 5, Qt::AlignRight);

  vtkSMSourceProxy::SafeDownCast(this->proxy())->GetProperty("Refresh")
      ->SetImmediateUpdate(1);
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onToggled(const bool checked)
{
  if(checked)
    {
    this->Timer->start(this->Interval);
    }
  else
    {
    this->Timer->stop();
    }
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onEditingFinished()
{
  // onEditingFinished is called only when the entered text is acceptable
  this->Interval = 1000 * this->IntEdit->text().toInt(); // convert to msec
  this->Timer->setInterval(this->Interval);
}

//-----------------------------------------------------------------------------
void pqPOpenFOAMPanel::onRefresh()
{
  vtkSMSourceProxy *sp = vtkSMSourceProxy::SafeDownCast(this->proxy());

  // force updating everything (RequestInformation() + RequestData())
  sp->GetProperty("Refresh")->Modified();
  sp->UpdatePipeline();

  // render all views (not only 3D views but also e.g. xy plots)
  pqApplicationCore::instance()->render();
}

//-----------------------------------------------------------------------------
// Update pipeline and set scene to the last timestep
void pqPOpenFOAMPanel::onTimeout()
{
  vtkSMSourceProxy *sp = vtkSMSourceProxy::SafeDownCast(this->proxy());

  // only update pipeline information (RequestInformation())
  sp->GetProperty("Refresh")->Modified();
  sp->UpdatePipelineInformation();
  sp->UpdatePropertyInformation(); // explicitly pull the property information

  // get the last timestep
  vtkSMDoubleVectorProperty *tsv
      = vtkSMDoubleVectorProperty::SafeDownCast(sp->GetProperty("TimestepValues"));
  double lastStep = tsv->GetElement(tsv->GetNumberOfElements() - 1);

  pqApplicationCore *app = pqApplicationCore::instance();

  // set animation time to the last timestep
  QList<pqAnimationScene*> scenes
      = app->getServerManagerModel()->findItems<pqAnimationScene *>();
  foreach (pqAnimationScene *scene, scenes)
    {
    scene->setAnimationTime(lastStep);
    }

  if(this->Rescale->isChecked())
    {
    // rescale
    QList<pqPipelineRepresentation*> pipes
        = app->getServerManagerModel()->findItems<pqPipelineRepresentation *>();
    foreach (pqPipelineRepresentation *pipe, pipes)
      {
      pipe->resetLookupTableScalarRange();
      }
    }

  // render all views (not only 3D views but also e.g. xy plots)
  app->render();
}
